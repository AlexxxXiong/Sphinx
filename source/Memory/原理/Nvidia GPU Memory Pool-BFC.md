# Nvidia GPU Memory Pool-BFC

----

内存池是linux系统中一种高效的内存管理机制。它预先分配一定数量的内存块并形成一个池，以便在需要内存时可以快速分配内存。与传统的内存分配方式相比，内存池管理可以大大提高内存分配和释放的效率，减少内存碎片的产生。

## 1.1 Linux内核内存池

- **Buddy 系统**：操作系统通常使用 `Buddy` 系统来分配和管理内存块。然而，`Buddy` 系统更适合管理大块内存，对于小对象的频繁分配与释放效率较低。
- **内存碎片**：频繁的小对象分配和释放容易导致大量内存碎片，降低内存利用效率。

在linux内核中，内存池管理主要采用以下两种方法：

### (1) Buddy System

伙伴系统以页为单位管理和分配内存。内存池中所有内存块的大小为2^n。

它将所有空闲页框分组到11个块链表中。

每个块链表包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。

当需要分配一块内存时，分配器会在内存池中找到最小的可用块，并将其分配给用户。

当不再使用某个内存块时，分配器将释放它并检查其“兄弟块”。

如果兄弟块也空闲，则将它们合并成一个大块，并继续向上检查，直到无法再合并为止。 



buddy系统的优点是可以减少内存碎片的产生，同时也提高了内存分配的效率。

然而，这种方法也有一些缺点。例如，大小不规则的内存块的分配和释放不方便，还可能存在内存的浪费。

### (2) Slab Allocator

slab分配器是在buddy系统分配的大内存的基础上进一步细化的小内存分配方法。

主要针对一些经常分配和释放的小对象，通常是内核数据结构。

**每当申请这样的对象时，slab分配器就会从slab列表中分配一个这个大小的单元，**

**当它被释放时，再次将其保存在列表中，而不是直接返回给伙伴系统，从而避免内部碎片。**



lab分配器可以高效地处理频繁申请和释放小对象（例如内核数据结构）的内存事务。

同时，可以显着节省内存空间，避免过多的内存碎片。



#### Slab 分配器的结构与工作机制

1. **Slab、Cache 和 Object**
   - **Slab**：由一块连续的物理内存区域组成，包含若干固定大小的对象。
   - **Cache**：由多个 Slab 组成，针对特定类型的小对象（如内核数据结构）进行优化管理。
   - **Object**：实际的小对象，保存在 Slab 内。
2. **分配与释放流程**
   - **分配对象**：
     - 当请求一个小对象时，Slab 分配器会从目标 Cache 中的 Slab 列表中分配一个空闲对象。
     - 如果当前 Cache 中没有空闲的 Slab，可以从 `Buddy` 系统申请一个新的 Slab，并将其添加到 Cache 中。
     - 分配成功的对象会标记为已使用状态。
   - **释放对象**：
     - 当对象被释放时，Slab 分配器将其标记为可用，并返回到相应的 Slab。
     - 该对象不会立即归还给 `Buddy` 系统，而是保持在 Cache 中以供后续分配使用。
     - 如果一个 Slab 中的所有对象都空闲，则该 Slab 可以被归还给 `Buddy` 系统。
3. **避免内部碎片**
   - **保持对象池**：对象释放后保持在 Cache 中而不是直接归还给 `Buddy` 系统，从而避免内部碎片。
   - **预分配对象池**：每个 Cache 都有一个预分配对象池（即空闲对象列表），减少频繁的分配与释放操作。

### 主要优点

1. **效率高**：
   - **频繁分配和释放**：针对内核数据结构等频繁分配和释放的小对象操作提供优化。
   - **预分配对象池**：对象池中的对象可以快速重复使用。
2. **内存节省**：
   - **减少内存碎片**：通过保持对象池避免了直接归还给 `Buddy` 系统而产生的内部碎片。
   - **对象重用**：保持对象池中的对象以供快速分配和重用。

### 总结

这段话主要强调了以下内容：

1. **Slab 分配器的作用**：针对频繁分配和释放的小对象提供更高效的内存管理。

2. **工作机制**：保持对象池避免内部碎片，快速分配与释放对象。

3. 优势

   ：

   - 避免直接归还给 `Buddy` 系统导致的内部碎片。
   - 高效处理频繁的小对象内存事务。