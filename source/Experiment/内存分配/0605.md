# 编译、调试TFlite源码

----

https://liuxiaofei.com.cn/blog/tensorflow%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/ Tensorflow源码解读

https://blog.csdn.net/Chris_zhangrx/article/details/119411904



https://chenjiehua.me/python/gdb-python-shared-library.html

1. 新建一个python环境来进行实验

```shell
conda create --name tflite --clone base
```

2. 编译debug

```shell
(tflite) archlab@v100-246:~/xy/experiments/toytest/tflite/tensorflow$ $HOME/bin/bazel build -c dbg 
```

## 调试a.out

```shell
# 非调试模式，指定输出文件名为test。
# ！！！ 可执行文件 test
g++ test.cc -o test

# 调试模式。如果没有通过 -o 选项指定输出文件名，编译器默认会生成一个名为 a.out 的一个完整的可执行二进制文件。。
g++ -g test.cc

# 进入调试
gdb ./a.out
```

```shell
# run
(gdb) r  
 
# quit
(gdb) quit

# 按函数打断点
(gdb) b main
Breakpoint 1 at 0x1216: file test.cc, line 5.

# 按行打断点
(gdb) list
1       // Filename: print_current_time.cc
2       #include <iostream>
3       #include <ctime>
4
5       int main() {
6           // 获取当前时间
7           std::time_t current_time = std::time(nullptr);
8           
9           // 将时间转换为本地时间
10          std::tm* local_time = std::localtime(&current_time);

# 达到注释，自动下调到对应行
(gdb) b 9
Breakpoint 2 at 0x1233: file test.cc, line 10.

# 查看断点信息
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001216 in main() at test.cc:5
2       breakpoint     keep y   0x0000000000001233 in main() at test.cc:10

# run 断点生效
(gdb) r
Starting program: /copy/home/archlab/xy/experiments/toytest/tflite/experiment/a.out 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, main () at test.cc:5
5       int main() {

# next
(gdb) n
7           std::time_t current_time = std::time(nullptr);

# next
(gdb) n

Breakpoint 2, main () at test.cc:10
10          std::tm* local_time = std::localtime(&current_time);

# 打印变量信息
(gdb) p current_time
$1 = 1717641872
# 打印地址。虚拟（逻辑）地址，而不是物理地址。
(gdb) p &current_time
$2 = (time_t *) 0x7fffffffda28

# 在使用 GDB 进行调试时，通常可以通过 step 命令（或简写 s）来进入函数的内部执行。然而，对于 std::time 这样的标准库函数，直接使用 step 命令可能无法进入其内部实现，主要是因为这些库函数通常已经预编译为二进制格式，并且没有附带调试信息。
# 在行上进入
(gdb) s
# 在函数上进入
(gdb) s func

# 在gdb中运行命令行
(gdb) shell cat test.cc 
// Filename: add_example.cc
#include <iostream>

// 定义一个函数，接收两个整数参数并返回它们的和
int addNumbers(int a, int b) {
    return a + b;
}

// main 函数是程序的入口点
int main() {
    int x = 5;
    int y = 10;
    // 调用 addNumbers 函数
    int result = addNumbers(x, y);
    // 打印结果
    std::cout << "The sum of " << x << " and " << y << " is " << result << std::endl;
    return 0;
}

# 记录调试
(gdb) set loggin enabled 
Already logging to gdb.txt.

# 查看日志
(gdb) shell cat gdb.txt 
Already logging to gdb.txt.
Already logging to gdb.txt.

# watchpoint 查看变量的值的变化
(gdb) watch *0x7fffffffda28

```

>  Here are some of the most frequently needed GDB commands:
>
>        break [file:][function|line]
>            Set a breakpoint at function or line (in file).
>         
>        run [arglist]
>            Start your program (with arglist, if specified).
>         
>        bt  Backtrace: display the program stack.
>         
>        print expr
>            Display the value of an expression.
>         
>        c   Continue running your program (after stopping, e.g. at a breakpoint).
>         
>        next
>            Execute next program line (after stopping); step over any function calls in the line.
>         
>        edit [file:]function
>            look at the program line where it is presently stopped.
>         
>        list [file:]function
>            type the text of the program in the vicinity of where it is presently stopped.
>         
>        step
>            Execute next program line (after stopping); step into any function calls in the line.
>         
>        help [name]
>            Show information about GDB command name, or general information about using GDB.
>         
>        quit
>        exit
>            Exit from GDB.

## 调试core

https://www.bilibili.com/video/BV1EK411g7Li?p=6&vd_source=95cdaed537ef42447d87ba42e0af33be

## 调试进程

```shell
# & 表示后台执行，不占用终端显示
./a.out &
>>> 21528

# 查看进程
ps -e | grep a.out

# 调试进程
gdb -p 21528


```





# 确保编译时包含调试信息。

### 确保编译时包含调试信息

请确保你在使用 Bazel 构建时添加了调试信息选项。你已经使用了 `--copt=-g` 选项，但可能需要确保所有相关部分都正确配置。

请尝试以下步骤：

### 1. 清理之前的构建

首先，清理之前的构建缓存：

```bash
$HOME/bin/bazel clean
```

### 2. 使用调试选项重新构建

使用以下命令重新构建 TensorFlow Lite：

```bash
$HOME/bin/bazel build --compilation_mode=dbg //tensorflow/lite:libtensorflowlite.so
```

或者，明确指定 C++ 编译选项：

```bash
$HOME/bin/bazel build --copt="-g" --copt="-O0" //tensorflow/lite:libtensorflowlite.so
```

### 3. 检查生成的共享库文件

在构建完成后，确保生成的共享库文件包含调试符号。你可以使用以下命令检查：

```bash
file ~/xy/experiments/toytest/tflite/tensorflow/bazel-bin/tensorflow/lite/libtensorflowlite.so
```

输出中应该包含类似 `with debug_info` 的信息。

### 4. 在 GDB 中加载共享库

现在，使用 GDB 加载共享库：

```bash
gdb ~/xy/experiments/toytest/tflite/tensorflow/bazel-bin/tensorflow/lite/libtensorflowlite.so
```

### 5. 添加源代码目录

在 GDB 提示符下，添加源代码目录：

```gdb
(gdb) directory /home/archlab/xy/experiments/toytest/tflite/tensorflow/tensorflow/lite
```

### 6. 设置断点并开始调试

例如，设置一个函数的断点并运行：

```gdb
(gdb) break some_function_in_tflite
(gdb) run
```

这些步骤应该帮助你确保生成的共享库文件包含调试符号，并在 GDB 中正确加载源代码进行调试。如果你仍然遇到问题，请提供更多信息以便进一步诊断。
