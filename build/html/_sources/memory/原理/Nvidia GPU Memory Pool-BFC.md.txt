# Nvidia GPU Memory Pool-BFC

----

内存池是linux系统中一种高效的内存管理机制。它预先分配一定数量的内存块并形成一个池，以便在需要内存时可以快速分配内存。与传统的内存分配方式相比，内存池管理可以大大提高内存分配和释放的效率，减少内存碎片的产生。



在计算机内存管理中，伙伴系统和页表有不同的角色，但它们之间仍然存在联系。让我们分别定义这两个概念，并了解它们之间的联系。

### 1. 页表（Page Table）
- **功能：** 将虚拟地址映射到物理地址，实现虚拟内存管理。
- **结构：**
  - 由页目录（Page Directory）和页表（Page Table）构成。
  - 虚拟地址通过多级页表转换成物理地址。
  - 虚拟地址通常分成页目录、页表和页偏移三个部分。
  
### 2. 伙伴系统（Buddy System）
- **功能：** 管理物理内存的分配与释放。
- **结构：**
  - 将物理内存按2的幂次划分成多个块（block），每个大小称为一个order。
  - 每个order的块按大小分类成不同的`bin`，在每个`bin`中包含多个块，称为`chunk`或`block`。

### 页表和伙伴系统之间的联系
1. **物理内存的管理：**
   - 页表管理虚拟地址空间的映射。
   - 页表中的物理页框号指向实际的物理内存地址。
   - 伙伴系统在物理内存中维护这些物理页框。
   - 因此，伙伴系统通过页表提供的虚拟地址映射，管理实际的物理内存。

2. **物理页框的分配：**
   - 页表中的每个页框指向一个实际的物理页。
   - 当需要分配新的页框时，伙伴系统负责分配实际的物理内存。
   - 伙伴系统根据页表的映射关系，将物理内存分配给特定的虚拟地址空间。

3. **内存回收：**
   - 当释放内存时，页表会更新映射关系，标记相应的页框为可用状态。
   - 伙伴系统接管已释放的物理页框，并将其重新加入适当的`bin`。

### 简化的关系示意图
```
虚拟内存 -> 页表 -> 物理页框号 -> 伙伴系统的`bin`（物理内存块）
```

### 流程举例
1. **分配内存：**
   1. 请求从虚拟内存分配一个页面。
   2. 查找页表，将虚拟页映射到一个空闲的物理页框。
   3. 伙伴系统为物理页框分配实际的内存块。

2. **释放内存：**
   1. 请求释放某个虚拟内存页面。
   2. 更新页表映射，标记对应的物理页框为可用。
   3. 伙伴系统将该物理内存块返回到合适的`bin`中。

### 结论
- 页表和伙伴系统通过虚拟地址到物理地址的映射关系建立联系。
- 页表负责管理虚拟地址空间，伙伴系统负责实际的物理内存管理。
- 伙伴系统与页表的结合提供了高效的虚拟内存管理与物理内存分配。







## 1.1 Linux内核内存池

- **Buddy 系统**：操作系统通常使用 `Buddy` 系统来分配和管理内存块。然而，`Buddy` 系统更适合管理大块内存，对于小对象的频繁分配与释放效率较低。
- **内存碎片**：频繁的小对象分配和释放容易导致大量内存碎片，降低内存利用效率。

在linux内核中，内存池管理主要采用以下两种方法：

### (1) Buddy System

伙伴系统以页为单位管理和分配内存。内存池中所有内存块的大小为2^n。

它将所有空闲页框分组到11个块链表中。

每个块链表包含大小为1、2、4、8、16、32、64、128、256、512和1024个连续页框的页框块。

当需要分配一块内存时，分配器会在内存池中找到最小的可用块，并将其分配给用户。

当不再使用某个内存块时，分配器将释放它并检查其“兄弟块”。

如果兄弟块也空闲，则将它们合并成一个大块，并继续向上检查，直到无法再合并为止。 



buddy系统的优点是可以减少内存碎片的产生，同时也提高了内存分配的效率。

然而，这种方法也有一些缺点。例如，大小不规则的内存块的分配和释放不方便，还可能存在内存的浪费。





### (2) Slab Allocator

slab分配器是在buddy系统分配的大内存的基础上进一步细化的小内存分配方法。

主要针对一些经常分配和释放的小对象，通常是内核数据结构。

**每当申请这样的对象时，slab分配器就会从slab列表中分配一个这个大小的单元，**

**当它被释放时，再次将其保存在列表中，而不是直接返回给伙伴系统，从而避免内部碎片。**



lab分配器可以高效地处理频繁申请和释放小对象（例如内核数据结构）的内存事务。

同时，可以显着节省内存空间，避免过多的内存碎片。



#### Slab 分配器的结构与工作机制

1. **Slab、Cache 和 Object**
   - **Slab**：由一块连续的物理内存区域组成，包含若干固定大小的对象。
   - **Cache**：由多个 Slab 组成，针对特定类型的小对象（如内核数据结构）进行优化管理。
   - **Object**：实际的小对象，保存在 Slab 内。
2. **分配与释放流程**
   - **分配对象**：
     - 当请求一个小对象时，Slab 分配器会从目标 Cache 中的 Slab 列表中分配一个空闲对象。
     - 如果当前 Cache 中没有空闲的 Slab，可以从 `Buddy` 系统申请一个新的 Slab，并将其添加到 Cache 中。
     - 分配成功的对象会标记为已使用状态。
   - **释放对象**：
     - 当对象被释放时，Slab 分配器将其标记为可用，并返回到相应的 Slab。
     - **该对象不会立即归还给 `Buddy` 系统，而是保持在 Cache 中以供后续分配使用。**
     - **如果一个 Slab 中的所有对象都空闲，则该 Slab 可以被归还给 `Buddy` 系统。**
3. **避免内部碎片**
   - **保持对象池**：对象释放后保持在 Cache 中而不是直接归还给 `Buddy` 系统，从而避免内部碎片。
   - **预分配对象池**：每个 Cache 都有一个预分配对象池（即空闲对象列表），减少频繁的分配与释放操作。

```c
struct kmem_cache {
    ...
    struct list_head slabs_full;    // 满载的 Slab 链表
    struct list_head slabs_partial; // 部分使用的 Slab 链表
    struct list_head slabs_free;    // 空闲的 Slab 链表
    ...
};

void *kmem_cache_alloc(struct kmem_cache *cache, gfp_t flags) {
    struct slab *slab;
    void *obj;

    // 从部分使用的 Slab 链表中分配对象
    slab = list_first_entry_or_null(&cache->slabs_partial, struct slab, list);
    if (slab) {
        obj = slab_alloc(slab, cache, flags);
        if (obj) {
            return obj;
        }
    }

    // 如果没有可用的对象，分配新的 Slab
    slab = kmem_cache_grow(cache, flags);
    if (!slab) {
        return NULL;
    }

    // 从新分配的 Slab 中分配对象
    return slab_alloc(slab, cache, flags);
}

```



### 主要优点

1. **效率高**：
   - **频繁分配和释放**：针对内核数据结构等频繁分配和释放的小对象操作提供优化。
   - **预分配对象池**：对象池中的对象可以快速重复使用。
2. **内存节省**：
   - **减少内存碎片**：通过保持对象池避免了直接归还给 `Buddy` 系统而产生的内部碎片。
   - **对象重用**：保持对象池中的对象以供快速分配和重用。

### 总结

这段话主要强调了以下内容：

1. **Slab 分配器的作用**：针对频繁分配和释放的小对象提供更高效的内存管理。

2. **工作机制**：保持对象池避免内部碎片，快速分配与释放对象。

3. 优势

   ：

   - 避免直接归还给 `Buddy` 系统导致的内部碎片。
   - 高效处理频繁的小对象内存事务。